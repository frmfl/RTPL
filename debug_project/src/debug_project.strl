module debug_project:
%	module Esterel_Exam_Review :
	input RANDOM1, RANDOM2, RANDOM3;
	output TA_INREVIEW, TA_SLEEPING;
	%output STUD_WANTREVIEW1, STUD_INREVIEW1, STUD_WANTREVIEW2, STUD_INREVIEW2, STUD_WANTREVIEW3, STUD_INREVIEW3;
	output WANT_REVIEW;
	output STUD_WANTREVIEW, STUD_INREVIEW;
	output TA_DISMISS_STUD;
	output STUDENTS_WAITING := 0 : combine integer with +;
	output TA_INSANE, STUD_INSANE, RACECONDITION, DEADLOCK, TA_TOOSLOW;

	output num_INREVIEWSTUDS :=0 : combine integer with +;
	output PRIO_counter :=0 : combine integer with +;
	
	output STUD_WANTREVIEW1, STUD_INREVIEW1, STUD_WANTREVIEW2, STUD_INREVIEW2, STUD_WANTREVIEW3, STUD_INREVIEW3;
	
	
	run TA; % never terminates
	 ||
	% produce random student pattern:
	
	% student Kevin
	loop await RANDOM1;
		% Student super insane
		present pre(STUD_WANTREVIEW1) or pre(STUD_INREVIEW1) then
		nothing;
		else
		run KEVIN / STUDENT [ constant 1/ const_prio; constant 2 / const_TOTAL_SEATS; signal STUD_WANTREVIEW1 / STUD_WANTREVIEW, STUD_INREVIEW1 / STUD_INREVIEW ];	% blocks until this instance finishes
		end present;
	end loop;
	 ||
	% student Stuart
	loop await RANDOM2;
	present pre(STUD_WANTREVIEW2) or pre(STUD_INREVIEW2) then
		nothing;
		else
		run STUART / STUDENT [ constant 2/ const_prio; constant 2 / const_TOTAL_SEATS; signal STUD_WANTREVIEW2 / STUD_WANTREVIEW, STUD_INREVIEW2 / STUD_INREVIEW ];	% blocks until this instance finishes
		end present;
	end loop;	 
	 ||
	% student Bob
	loop await RANDOM3;
	present pre(STUD_WANTREVIEW3) or pre(STUD_INREVIEW3) then
		nothing;
		else
		run BOB / STUDENT [ constant 3/ const_prio; constant 2 / const_TOTAL_SEATS; signal STUD_WANTREVIEW3 / STUD_WANTREVIEW, STUD_INREVIEW3 / STUD_INREVIEW ];	% blocks until this instance finishes
		end present;
	end loop;
	 ||
	loop
		present STUD_WANTREVIEW1 or STUD_WANTREVIEW2 or STUD_WANTREVIEW3 then 
			emit STUD_WANTREVIEW;
		end present;
			
		pause;
	end loop;
		||
		loop
		present STUD_INREVIEW1 or STUD_INREVIEW2 or STUD_INREVIEW3 then 
			emit STUD_INREVIEW;
		end present;
			
		pause;
	end loop;
	
	||
	
	run OBSERVER; % never terminates
		
	
end module

%%%%%%%%%%%%%%%%%%%%%%%%%% STUDENT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

module STUDENT :
	
	input TA_INREVIEW, TA_SLEEPING;
	
	input STUDENTS_WAITING : integer; % to increment number of waiting students
	
	input TA_DISMISS_STUD; % from TA
	output PRIO_counter : integer;
	
	output STUD_INREVIEW, STUD_WANTREVIEW;
	
	constant const_TOTAL_SEATS : integer;
	constant const_prio : integer;
	
	% use variable to check, whether its the students turn or not yet
	var WL_position := 0 : integer in
		
			emit PRIO_counter(const_prio);
		
		
			trap T0 in
			[
		
			%if at least one free seat
			if ((pre(?STUDENTS_WAITING)) < const_TOTAL_SEATS  ) then  % added "pre(.." that there is not cyclic loop because checking of value and incrementing in the same cycle makes no sence
						
				if const_prio = 3 then
				
					WL_position := pre(?STUDENTS_WAITING);
					
				elsif const_prio = 2 then
					
					if ?PRIO_counter >= 5 then
					
						WL_position := pre(?STUDENTS_WAITING) + 2;
					
					else 
					
						WL_position := pre(?STUDENTS_WAITING);
					
					end if;
					
				else
				
					if ?PRIO_counter = 1 then
						
						WL_position := pre(?STUDENTS_WAITING);
						
					elsif ?PRIO_counter = 3 or ?PRIO_counter = 4 then
						
						WL_position := pre(?STUDENTS_WAITING) + 2;
						
					else 
					
						exit T0;
						
					end if;
					
				end if;	
		
				
				emit STUDENTS_WAITING(1);
							
				trap T1 in
				
				[
					% this loop counts down "sig_students_before_me" for every "TA_DISMISS_STUD" ( which means that a student finished review)
 					% if all other longer waiting students finished review, the trap T1 exists the loop
					loop
						emit STUD_WANTREVIEW;
						
						WL_position := WL_position - 1;
						
						if WL_position < 1 then
							exit T1;
						end;	
									
						%await immediate TA_DISMISS_STUD; % in case there are others waiting

						pause % await immediate is not allowed without "pause" in loops

					end loop
					%each TA_DISMISS_STUD
				]
				
				end trap;
				
				
			pause;
			emit STUD_INREVIEW;

			else
		
			nothing; %nothing. Student disappears because waiting room is full.
		
			end if;
			
			]
			end trap;
			 %nothing. Student disappears because waiting room is full.
		
	end var;
end module



%%%%%%%%%%%%%%%%%%%%%%%%%% TA %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

module TA:	
% : combine integer with +
	input STUDENTS_WAITING : integer;
	input STUD_WANTREVIEW;
	output TA_SLEEPING, TA_INREVIEW;
	%%  to tell other students, that student is done
	output TA_DISMISS_STUD;
	%%
	
	loop	 
		emit STUDENTS_WAITING(pre(?STUDENTS_WAITING));
		
		present pre(STUD_WANTREVIEW) then 	% added pre, that there are no cyclic paths	
				
				emit TA_INREVIEW;
				emit STUDENTS_WAITING(-1);
		
		else
		
			emit TA_SLEEPING
		
		end present;
		
		pause;
		
	end loop;
end module



%%%%%%%%%%%%%%%%%%%%%%module OBSERVER%%%%%%%%%%%%%%%%%%%%%%%%%%%%

module OBSERVER:
	input TA_INREVIEW, TA_SLEEPING; 
	input STUD_INREVIEW1, STUD_INREVIEW2, STUD_INREVIEW3, STUD_WANTREVIEW1, STUD_WANTREVIEW2, STUD_WANTREVIEW3;
	input STUD_WANTREVIEW, STUD_INREVIEW;
	output TA_INSANE, STUD_INSANE, RACECONDITION, DEADLOCK, TA_TOOSLOW;

	output num_INREVIEWSTUDS : combine integer with +;
	
	loop
		%TA is not in both states at once
		present (TA_INREVIEW and TA_SLEEPING) then
			emit TA_INSANE;
		end present;
		% STUDENT is not in both states at once
		present (STUD_INREVIEW1 and STUD_WANTREVIEW1) then
			emit STUD_INSANE;
		end present;
		present (STUD_INREVIEW2 and STUD_WANTREVIEW2) then
			emit STUD_INSANE;
		end present;
		present (STUD_INREVIEW3 and STUD_WANTREVIEW3) then
			emit STUD_INSANE;
		end present;
		
		
		%%%%%%%%%%%%% RACECONDITION %%%%%%%%%%%%%%%
		% Racecondition if more than one student is IN_REVIEW!
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		present STUD_INREVIEW1 then
		emit num_INREVIEWSTUDS(1);
		end present;
		
		present STUD_INREVIEW2 then
		emit num_INREVIEWSTUDS(1);
		end present;
		
		present STUD_INREVIEW3 then
		emit num_INREVIEWSTUDS(1);
		end present;
		
		if ?num_INREVIEWSTUDS >1 then
		emit RACECONDITION;
		end if;
		
		%%%%%%%%%%%%% DEADLOCK %%%%%%%%%%%%%%%
		% Deadlock if TA sleeps while a student requests Review!
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		present TA_SLEEPING and STUD_WANTREVIEW then
		emit DEADLOCK;		
		end present ;
		
		%%%%%%%%%%%%% TA_TOOSLOW %%%%%%%%%%%%%%%
		% Too Slow if DEADLOCK present for more than one tick!
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		present pre(DEADLOCK) then
			present DEADLOCK then
				emit TA_TOOSLOW;
			end present;
		end present;
		
		
		pause;
	end loop;
end module


